//! 把初步解析得到的抽象语法树 AST 规范化为语义语法树 SST.
//! 
//! 初步解析得到的 AST 中包含大量中间代码生成器无法识别、意义不明的结点, 例如
//! `UnresolvedVariable` 的具体类型未知、`RawInitList` 初始化列表层级不一、
//! 杂乱无章。规范化操作会将 AST 中的这些结点转换为语义语法树 SST 中的结点,
//! 使得 SST 中的每个结点都有明确的语义, 便于后续的中间代码生成.
//! 
//! 规范化操作在表达式上的的主要工作是:
//! 
//! * 根据变量定义的类型, 把 `RawInitList` 转换为 `ArrayInitList`.
//! * 如果表达式可以在编译期求值, 就求值.
//! * 计算表达式的类型, 通过添加 `ImplicitCast` 把不符合 SST 类型要求的
//!   表达式转换为符合要求的表达式. 例如， SST 的加法表达式要求两边操作数
//!   类型一致, 但 AST 没有这个要求. 在规范化时, 需要添加 `ImplicitCast`
//!   把两边操作数转换为相同的类型; 又比如, 加法表达式要求两个操作数都是右值,
//!   但 AST 没有这个要求. 在规范化时, 需要添加 `LValueToRValue` 这种
//!   隐式转换.
//! 
//! 规范化操作在变量定义上的主要工作是:
//! 
//! * 计算变量定义的类型. AST 的变量定义结点和 SST 的变量定义结点类型不一致,
//!   前者是类型不完整的 `UnresolvedVariable`, 后者是类型明确的 `Variable`.
//!   在规范化时, 需要根据数组下标计算出变量的实际类型, 把 `UnresolvedVariable`
//!   转换为 `Variable`.
//! * 常量的求值: 被标记为 `const` 的变量可能会用作数组维度等常量用途, 在编译期就要被求值.

pub mod scope;
pub mod expr;